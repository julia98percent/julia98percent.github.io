정보처리기사(실기)
----------
## 6-02 UI 설계

* UI 흐름 설계란?
    * 업무의 흐름이나 업무 수행과 관련된 일련의 클릭에 의한 화면의 위치와 흐름을 흐름도 형식으로 표현하는 활동

* UI 설계서 구성
    1. UI 설계서 표지 작성: UI 설계서에 포함될 프로젝트명 또는 시스템명 포함
    2. UI 설계서 개정 이력 작성
    3. UI 요구사항 정의 작성: 사용자의 UI 요구사항들을 확인하고 정리
    4. 시스템 구조 작성: UI 프로토타입 재확인 / UI 요구사항들과 UI 프로토타입에 기초해 UI 시스템 구조 설계
    5. 사이트 맵(Site Map) 작성: UI 시스템 구조의 내용을 사이트 맵의 형태로 작성
    6. 프로세스 정의서 작성: 사용자 관점에서 요구되는 프로세스들을 진행되는 순서에 맞추어 정리
    7. 화면 설계: UI 프로토타입과 UI 프로세서 정의를 참고해 각 페이지별로 필요한 화면 설계

* UI 설계 원리
    * 실행차를 줄이기 위한 UI 설계 원리
        * (실행차는 사용자가 원하는 목적과 실행 *기능*이 다르기 때문에 발생)
        * 사용 의도 파악
        * 행위 순서 규정
        * 행위의 순서대로 실행
    * 평가차를 줄이기 위한 UI 설계 원리 
        * (평가차는 사용자가 원하는 목적과 실행 *결과*가 다르기 때문에 발생)
        * 수행한 키 조작 결과를 사용자가 빠르게 지각하도록 유도
        * 키 조작으로 변화된 시스템의 상태를 사용자가 쉽게 인지하도록 유도
        * 사용자가 가진 원래 의도와 시스템 결과 간의 유사 정도를 사용자가 쉽게 파악하도록 유도

* 화면과 폼의 흐름 설계
    1. 화면에 표현되어야 할 기능 및 비기능적 요구사항 검토
    2. 화면의 입력 요소 및 유스케이스를 통한 UI 요구사항 확인
    3. 유스케이스 설계
        * UI 요구사항을 바탕으로 액터별 시나리오 구상
        * UI 요구사항을 바탕으로 액터 세분화
        * UI 유스케이스 설계
    4. 기능 및 양식 확인

<hr/>
<br/>

* UI 상세설계 프로세스
    1. UI 요구사항 최종 확인
    2. UI 구조 설계
    3. 사용자 기반 메뉴 구조 설계
    4. 화면 설계
    5. 하위 시스템 단위의 내, 외부 상세 화면과 폼 설계

<hr/>
<br/>

* UI 설계 도구란?
    * 사용자와 시스템 사이에 의사소통하 수 있는 일시적 또는 영구적인 접근을 목적으로 만들어진 물리적, 가상적 매개체인 UI의 설계를 지원하는 도구

* 일반적인 UI 개발 프로세스는 분석, 설계, 구현의 절차를 거쳐 요구사항에 부합하는 화면의 구현으로 이루어짐

* UI 설계 도구의 세분화
    * 화면 설계 도구
        * 파워 목업
        * 발사믹 목업
        * 카카오 오븐
    * 프로토타이핑 도구
        * UX핀
        * 액슈어
        * 네이버 프로토나우
    * UI 디자인 도구
        * 스케치
        * 어도비 익스피리언스 디자인 CC
    * UI 디자인 산출물로 작업하는 츠로토타이핑 도구
        * 인비전
        * 픽사에이트
        * 프레이머

<hr/>
<br/>
        
## 7-01 애플리케이션 테스트 케이스 설계

* 소프트웨어 테스트란?
    * 개발된 응용 애플리케이션이나 시스템이 사용자가 요구하는 기능과 성능, 사용성, 안정성 등을 만족하는지 확인하고, 노출되지 않은 숨어있는 소프트웨어의 결함을 찾아내는 활동

* 소프트웨어 테스트의 필요성
    * 오류 발전 관점
    * 오류 예방 관점
    * 품질 향상 관점

* 소프트웨어 테스트의 원리
    * 테스팅은 결함이 존재하을 밝히는 것
    * 완벽한 테스팅은 불가능
    * 개발 초기에 테스팅 시작
    * 결함집중 -> 파레토 법칙
    * 살충제 패러독스
    * 테스팅은 정황에 의존적
    * 오류-부재의 궤변

* 소프트웨어 테스트 프로세스
    1. 테스트 계획
    2. 테스트 분석 및 디자인
    3. 테스트 케이스 및 시나리오 작성
    4. 테스트 수행
    5. 테스트 결과 평가 및 리포팅

* 소프트웨어 테스트 산출물 - 결시계케
    * 테스트 계획서
        * 테스트 목적과 범위 정의, 대상 시스템 구조 파악 등 테스트 수행을 계획한 문서
    * 테스트 케이스
        * 테스트를 위한 설계 산출물
    * 테스트 시나리오
        * 테스트 수행을 위한 여러개의 테스트 케이스의 집합
    * 테스트 결과서
        * 테스트 결과럴 정리한 문서
    
* 소프트웨어 테스트 유형
    1. 프로그램 실행 여부에 따른 분류
        * 정적 테스트: 프로그램의 실행 없이 구조를 분석하여 논리성을 검증하는 테스트
            * 동료 검토, 워크스루, 인스펙션
        * 동적 테스트: 프로그램 실행을 요구하는 테스트
            * 화이트박스 테스트, 블랙박스 테스트
    2. 테스트 기법에 따른 분류
        * 화이트 박스 테스트(= 구조 테스트): 프로그램 내부 로직을 보면서 수행하는 테스트 / 내부 구조를 기반으로 문장 검증, 경로 검증 등을 수행
            * 제어구조 테스트: 소프트웨어의 논리적 복잡도 측정 후 수행 경로들의 집합을 정의하는 테스트
            * 루프 테스트: 프로그램의 루프 구조에 국한해서 실시하는 테스트
            * (...) 커버리지 테스트를 포함
        * 블랙박스 테스트(= 기능 테스트): 프로그램 외부 사용자의 요구사항 명세를 보면서 수행하는 테스트
            * 동등 분할 테스트: 입력 데이터의 영역을 유사한 도메인별로 유효 값/무효 값을 그룹핑하여 대표값 테스트 케이스를 도출하여 테스트하는 기법
            * 경계 값 분석 테스트: 등가분할 후 경계 값 부분에서 오류 발생 확률이 높기에 경계값을 포함하여 테스트 케이스를 설계하여 테스트하는 기법
            * 결정 테이블 테스트: 요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합하여 테스트하는 기법
            * 상태전이 테스트: 테스트 대상/시스템이나 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이 되는 경우의 수를 수행하는 테스트 기법
            * 유스케이스 테스트: 시스템이 실제 사용되는 유스케이스로 모델링 되어있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화하여 수행하는 테스트 기법
            * 분류트리 테스트: SW의 일부 또는 전체를 트리 구조로 분석 및 표현하여 테스트 케이스를 설계하여 테스트하는 기법
            * 페어와이즈 테스트: Test data 값들 간에 최소한 한 번씩을 조합하는 방식
    3. 테스트 시각에 따른 분류
        * 검증(Verification)
            * 소프트웨어 과정을 테스트
            * 올바른 제품을 생산하고 있는지 검증
            * 이전 단계에서 설정된 개발 규격과 요구를 충족시키는지 판단
            * 개발자 혹은 시험자의 시각으로 바라보는 과정
        *  확인(Validation)
            * 소프트웨어 결과를 테스트
            * 만들어진 제품이 제대로 동작하는지 확인
            * 최종 사용자 요구 또는 소프트웨어 요구에 적합한지 판단
            * 사용자 시각으로 바라보는 과정
    4. 테스트 목적에 따른 분류
        * 회복(Recovery)테스트: 시스템에 고의로 실패를 유도하고, 시스템의 정상적 복귀 여귀를 테스트하는 기법
        * 안전(Security)테스트: 불법적인 소프트웨어가 접근하여 시스템을 파괴하지 못하도록 소스 코드 내의 보안적인 결합을 미리 점검하는 테스트 기법
        * 강도(Stress)테스트: 시스템에 과다 정보량을 부과하여 과부하 시에도 시스템이 정상적으로 작동되는지를 검증하는 테스트 기법
        * 성능(Performance)테스트: 사용자의 이벤트에 시스템이 응답하는 시간, 특정 시간 내애 처리하는 업무량, 사용자 요구에 시스템이 반응하는 속도 등을 측정하는 테스트 기법
        * 구조(Structure)테스트: 시스템의 내부 논리 경로, 소스 코드의 복잡도를 평가하는 테스트 기법
        * 회귀(Regression)테스트: 오류를 제거하거나 수정한 시스템에서 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지 확인하는 일종의 반복 테스트 기법
        * 병행(Parallel)테스트: 변경된 시스템과 기존 시스템에 동일한 데이터를 입력후 결과를 비교하는 테스트 기법
    5. 테스트 종류에 따른 분류
        * 명세 기반 테스트: 프로그램의 요구사항 명세서를 기반으로 테스트 케이스를 선정하여 테스트하는 기법
        * 구조 기반 테스트: 소프트웨어 내부 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트 기법
        * 경험 기반 테스트: 유사 소프트웨어나 유사 기술 평가에서 테스터의 경험을 토대로 한, 직관과 기술 능력을 기반으로 수행하는 테스트 기법
    
* 테스트 케이스(Test Case)란?
    * 특정 요구사항에 준수하는 지를 확인하기 위해 개발된 입력값, 실행 조건, 예상된 결과의 집합

* 테스트 케이스 작성 절차
    1. 테스트 계획 검토 및 자료 확보
    2. 위험 평가 및 우선순위 결정
    3. 테스트 요구사항 정의
    4. 테스트 구조 설계 및 테스트 방법 결정
    5. 테스트 케이스 정의
    6. 테스트 케이스 타당성 확인 및 유지보수

* 테스트 오라클(Test Oracle)이란?
    * 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참 값을 입력하여 비교하는 기법
        * 참(True) 오라클: 모든 입력값에 대하여 기대하는 결과를 생성함으로써 발생된 오류를 모두 검출 가능
        * 샘플링(Sampling) 오라클: 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해 주는 오라클
        * 휴리스틱(Heuristic) 오라클: 샘플링 오라클을 개선한 오라클로, 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클
        * 일관성(Consistent) 오라클: 애플리케이션 변경이 있을 때, 수행 전과 후의 결괏값이 동일한지 확인하는 오라클

<hr/>
<br/>

* 테스트 레벨(Test Level)이란?
    * 함께 편성되고 관리되는 테스트 활동의 그룹
    * 각각의 테스트 레벨은 서로 독립적
        * 단위 테스트: 사용자 요구사항에 대한 단위 모듈, 서브루틴 등을 테스트하는 단계
        * 통합 테스트: 단위 테스트를 통과한 모듈 사이의 인터페이스, 통합된 컴포넌트 간의 상호작용을 검증하는 테스트를 하는 단계
        * 시스템 테스트: 통합된 단위 시스템의 기능이 시스템에서 정상적으로 수행되는지를 검증하는지 테스트하는 단계
        * 인수 테스트: 계약상의 요구사항이 만족되었는지 확인하기 위한 테스트

* 테스트 시나리오(Test Scenario)란?
    * 테스트 수행을 위한 여러 테스트 케이스의 집합
    * 테스트 케이스의 동작 순서를 기술한 문서이며 테스트를 위한 절차를 명세한 문서

* 테스트 환경 구축이란?
    * 개발된 응용 소프트웨어가 실제 운영 시스템에서 정상적으로 작동되는지 테스트하기 위해 실제 운영 시스템과 동일한(또는 유사한) 사양의 하드웨어, 소프트웨어, 네트워크 등의 환경 시설을 구축하는 활동
        * 하드웨어 기반의 테스트 환경 구축
        * 소프트웨어 기반의 테스트 환경 구축
        * 가상 시스템 기반의 테스트 환경 구축
            * 물리적으로 개발 환경 및 운영 환경과 별개로 독립된 테스트 환경을 구축하기 힘든 경우 사용

* 테스트 데이터란?
    * 컴퓨터의 동작이나 시스템의 적합성을 시험하기 위해 특별히 개발된 데이터 집합
        * 실제 데이터: 선행된 연산에 의해 얻어진 데이터
        * 가상 데이터: 인위적으로 만들어진 데이터

* 테스트 조건
    * 테스트 시작 조건
    * 테스트 종료 조건
    * 테스트 성공과 실패의 판단 기준

<hr/>
<br/>

## 7-02 애플리케이션 통합 테스트

* 통합 테스트(Integration Test)란?
    * 소프트웨어 각 모듈 간의 인터페이스 관련 오류 및 결함을 찾아내기 위한 체계적인 테스트 기법
    * 소규모 프로그램 또는 프로그램의 일부

* 통합 테스트 수행 방법의 분류
    * 점증적인 방법
        * 상향식 통합방식
        * 하향식 통합방식
    * 비점증적인 방식
        * 빅뱅 방식: 모든 컴포넌트를 사전에 통합하여 전체 프로그램을 한꺼번에 테스트하는 것

* 하향식 통합(Top Down)이란? ⬇️
    * 메인 제어 모듈(프로그램)로부너 아래 방향으로 제어의 경로를 따라 이동하면서 하향식으로 통합하면서 테스트를 진행
    * 깊이 우선 방식 또는 너비 우선 방식으로 통합
    1. 메인 제어 모듈은 작성된 프로그램을 사용
    2. 깊이 우선 방식 또는 너비 우선 방식에 따라, 하위 모듈인 **스텁**이 한 번에 하나씩 실제 모듈로 대체
    3. 각 모듈 또는 컴포넌트를 통합하면서 테스트 수행

* 상향식 통합(Bottom Up)이란? ⬆️
    * 최하위 레벨의 모듈 또는 컴포넌트로부터 위쪽 방향으로 제어의 경로를 따라 이동하면서 구축과 테스트를 수행
    1. 하위레벨의 모듈을 클러스터(Cluster; 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹)로 결합
    2. 상위의 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈인 **드라이버** 작성
        * 드라이버: 상위의 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈
    3. 각 통합된 클러스터 단위 테스트
    4. 테스트가 완료되면 각 클러스터들은 프로그램의 위쪽으로 결합되며, 드라이버는 실제 모듈로 대체

* 테스트 자동화 도구란?
    * 반복적인 테스트 작업을 스크립트 형태로 구현
    * 테스트 시간 단축과 인력 투입 비용 최소화
    * 쉽고 효율적인 테스트 수행

* 테스트 자동화 도구의 장점
    * 사용자 요구 기능의 일관성 검증에 유리
    * 테스트 결괏값에 대한 객관적인 평가 기준 제공
    * 테스트 결과의 그래프 등 다양한 표시 형태 제공
    * UI가 없는 서비스의 경우에도 정밀한 테스트 가능

* 테스트 자동화 도구의 단점
    * 도구 사용 방법에 대한 교육 및 학습 필요
    * 도구를 프로세스 단계별로 적용하기 위한 시간, 비용, 노력이 필요
    * 상용 도구의 경우 고가, 유지 관리 비용이 높아 추가 투자 필요

* 테스트 자동화 도구 유형
    * 정적 분석 도구(Static Analysis Tools)
        * 만들어진 애플리케이션을 실행하지 않고 분석하는 도구
    * 테스트 실행 도구(Test Execution Tools)
        * 테스트를 위해 작성된 스크립트를 실행
        * 데이터 주도 접근 방식과 키워드 주도 접근 방식으로 나눌 수 있음
    * 성능 테스트 도구(Performance Test Tools)
        * 가상의 사용자를 생성해 테스트를 수행함으로써 성능 목표를 달성하였는지를 확인하는 도구
    * 테스트 통제 도구(Test Control Tools)
        * 테스트 계획 및 관리를 위한 *테스트 관리 도구*, 테스트 수행에 필요한 데이터와 도구를 관리하는 *형상 관리 도구*, 테스트에서 발생한 결함에 대해 관리하거나 협업을 지원하기 위한 *결함 추적/관리 도구* 등이 있음

* 데이터 주도 접근 방식: 테스트 데이터를 스프레드시트에 저장
* 키워드 주도 접근 방식: 테스트를 수행할 동작을 나타내는 키워드와 테스트 데이터를 스프레드시트에 저장

* 테스트 하네스(Test Harness)란?
    * 애플리케이션 컴포넌트 및 모듈을 테스트하는 환경의 일부분
    * 테스트를 지원하기 위한 코드와 데이커

* 테스트 하네스 구성요소
    * 테스트 드라이버(Test Driver)
        * 테스트 대상 하위 모듈 호출
        * 파라미터 전달
        * 모듈 테스트 수행 후의 결과를 도출
        * -> 상향식 테스트에 필요
    * 테스트 스텁(Test Stub)
        * 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구
        * -> 하향식 테스트에 필요
    * 테스트 슈트(Test Suites)
        * 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합
    * 테스트 케이스(Test Case)
        * 입력값, 실행 조건, 기대 결과 등의 집합, 테스트 항목의 명세서
    * 테스트 스크립트(Test Script)
        * 자동화된 테스트 실행 절차에 대한 명세
        * 테스트 케이스 동작 순서에 따른 집합
    * 목 오브젝트(Mock Object)
        * 사용자의 행위를 조건부로 사전에 입력해 두면, 그 상황에 예정된 행위를 수행하는 객체

<hr/>
<br/>

* 소프트웨어 결함
    * 에러(Error)
    * 결함(Defect)
    * 결점(Fault)
    * 버그(Bug)
    * 실패(Failure)
    * 에러/오류: 에러는 결함의 원인 / 일반적으로 사람에 의해 생성된 실수
    * 결함/결점/버그: 에러 또는 오류가 원인이 되어 소프트웨어 제품에 포함되어 있는 결함
    * 실패/문제: 소프트웨어 제품에 포함된 결함이 실행될 때 발생되는 현상

* 테스트 리포팅
    * 테스트 결과 정리: 모든 테스트가 완료되면 테스트 케이스 설계부터 테스트 결과까지 모두 포함된 문서 작성
    * 테스트 요약문서: 대상 소프트웨어의 품질 상태를 포함한 문서 작성
    * 품질 상태: 정량화된 품질 지표 포함
    * 테스트 결과서: 테스트 결과서는 결함과 관련한 사항을 중점적으로 기록
    * 테스트 실행 절차 및 평가: 단계별 테스트 종료 시 테스트 실행 절차를 리뷰하고 그 결과에 따라 실행 절차를 최적화

* 테스트 결함 관리
    * 각 단계별 테스트 수행 후 발생한 결함의 재발 방지와 유사 결함 발견 시 처리 시간 단축을 위해 결함을 추적하고 관리하는 활동

* 결함 관리 프로세스
    1. 에러 발견
    2. 에러 등록
    3. 에러 분석: 단순 에러인지 실제 결함인지 분석
    4. 결함 확정
    5. 결함 할당: 결함을 해결할 담당자 지정
    6. 결함 조치
    7. 결함 조치 검토 및 승인: 수정이 완료된 결함에 대해 확인 테스트 수행
    
* 결함 추이 분석이란?  
    * 테스트 완료 후 발견된 결함의 결함 관리 측정 지표의 속성값들을 분석하고, 향후 애플리케이션의 어떤 모듈 또는 컴포넌트에서 결함이 발생할지를 추정하는 작업

* 결함 추이 분석
    * 결함 분포 분석: 각 애플리케이션 모듈 또는 컴포넌트의 특정 속성에 해당하는 결함의 수를 특정하여 결함의 분포를 분석
    * 결함 추세 분석: 테스트 진행 시간의 흐름에 따른 결함의 수를 츠겅하여 결함 추세를 분석
    * 결함 에이징 분석: 등록된 결함에 대해 특정한 결함 상태의 지속시간을 측정하여 분석

<hr/>
<br/>

* 테스트 커버리지(Test Coverage)란?
    * 주어진 테스트 케이스에 의해 수행되는 소프트웨어의 테스트 범위를 측정하는 테스트 품질 측정 기준
    * 테스트의 정확성과 신뢰성을 향상시킴

* 테스트 커버리지 유형
    * 기능 기반 커버리지: 테스트 대상 애플리케이션 전체 기능을 모수로 설정
    * 라인 커버리지: 애플리케이션 전체 소스 코드의 라인 수를 모수로 설정 / 단위 테스트에서는 이 라인 커버리지를 척도로 삼음
    * 코드 커버리지: 소스 코드의 구문, 조건, 결정 등의 구조 코드 자체가 얼마나 테스트 되어있는지를 측정하는 방법

* 코드 커버리지
    * 구문 커버리지: 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 커버리지 / 조건문 결과와 관계없이 구문 실행 개수로 계산
    * 결정 커버러지: 프로그램 내의 전체 결정문이 적어도 한 번은 참과 거짓의 결과를 수행하는 커버리지
    * 조건 커버리지: 결정 명령문 내의 각 조건이 적어도 한 번은 참과 거짓의 결과가 되도록 수행하는 커버리지
    * 조건/결정 커버리지: 전체 조건식뿐만 아니라 개별 조건식도 참 한번, 거짓 한번 결과가 되도록 수행하는 커버리지
    * 변경 조건/결정 커버리지: 각 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 함
    * 다중 조건 커버리지: 결정 조건 내 모든 개발 조건식의 모든 가능한 조합을 100% 보장하는 커버리지

* 결함 심각도별 분류
    * 치명적(Critical) 결함: 기능이나 제품의 테스트를 완전히 방해하거나 못하게 하는 결함
    * 주요(Major) 결함: 기능이 기대와 많이 다르게 동작하거나 그 기능이 해야하는 것을 못하는 결함
    * 보통(Normal) 결함: 제품이나 프로그램이 특정 기준을 충족하지 못하거나 전체에 영향을 주지 않는 일부 기능이 부자연스러운 결함
    * 경미한(Minor) 결함: 사용상의 불편함을 유발하는 결함
    * 단순(Simple) 결함: 사소한 버그라고 하며, 기능에는 영향이 없지만 수정되어야 하는 결함

* 결함 우선순위
    * 발생한 결함이 얼마나 짜르게 처리되어야 하는지를 결정하는 척도
    * 결함 심각도가 높아도 우선순위가 반드시 높은 것은 아님
    * 결정적(Critical): 이슈가 발생하면 일반적으로 전체 기능이 동작하지 않고, 어떤 테스트도 더 이상 진행할 수 없음
    * 높음(High): 중요한 결함이 수정되는 동안, 이 우선순위의 결함은 종료 기준에 대한 테스트 활동을 하기 위해서 수정되어야 하는 다음 후보가 됨
    * 보통(Medium): 실패가 발생했을 때 올바른 에러 메세지가 출력되지 않는 것과 갘은 에러가 이 우선순위로 분류될 수 있음
    * 낮음(Low): 디자인에서 일부 강화하거나 사용자 경험을 향상시키기 위한 작은 기능 구현에 대한 요청이 우선순위로 분류

<hr/>
<br/>

## 7-03 애플리케이션 성능 개선

* 애플리케이션 성능 측정 지표
    * 처리량(Throughput): 애플리케이션 주어진 시간에 처리할 수 있는 트랜잭션의 수
    * 응답 시간(Response Time): 사용자 입력이 끝난 후, 애플리케이션의 응답 출력이 개시될 때까지의 시간
    * 경과 시간(Turnaround Time): 애플리케이션에 사용자가 요구를 입력한 시점부터 트랜잭션을 처리 후 그 결과의 출력이 완료될 때까지 걸리는 시간
    * 자원 사용률(Resource Usage): 애플리케이션이 트랜잭션을 처리하는 동안 사용하는 CPU 사용량, 메모리 사용량, 네트워크 사용량

* 유형별 성능 분석 도구
    * 성능/부하/스트레스 점검 도구
        * 애플리케이션의 성능 점검을 위해 가상의 사용자를 점검 도구 상에서 인위적으로 생성한 뒤, 시스템의 부하나 스트레스를 통해 성능 측정 지표인 처리량, 응답 시간, 경과 시간 등을 점검하기 위한 도구
    * 모니터링 도구
        * 애플리케이션 실행 시 자원 사용량을 확인하고 분석 가능한 도구
    
* 데이터베이스 관련 성능 저하 원인
    * 데이터베이스 락(DB Lock): 대량의 데이터 조회, 과도한 업데이트, 인덱스 생성 시 발생하는 현상
    * 불필요한 데이터베이스 패치(DB Fetch): 실제 필요한 데이터보다 많은 대량의 데이터 요청을 들어올 경우 웅답 시간 저하 현상 발생
    * 연결 누수(Connection Leak): DB 연결과 관련한 JDBC 객체를 사용 후 종료하지 않은 경우 발생
    * 부적절한 커넥션 풀 크기(Connection Pool Size): 너무 작거나 쿠게 설정한 경우 성능 저하 현상이 발생할 가능성 존재
    * 확정(Commit) 관련: 트랜잭션이 확정(Commit)되지 않고 커넥션 풀에 반환될 때 성능 저하 가능성 존재

* 내부 로직으로 인한 성능 저하 원인
    * 웹 애플리케이션의 인터넷 접속 불량
    * 특정 파일의 업로드, 다운로드로 인한 성능 저하
    * 정상적으로 처리되지 않는 오류 처리로 인한 성능 저하

* 외부 호출(HTTP, 소켓 통신)로 인한 성능 저하 원인
    * 임의의 트랜잭션이 수행되는 동안 외부 트랜잭션이 장시간 수행되거나 타임 아웃이 일어나는 경우

* 잘못된 환경 설정이나 네트워크 문제로 인한 성능 저하 원인
    * 환경 설정으로 인한 성능 저하: 스레드 풀(Thread Pool), 힙 메모리(Heap Memory)의 크기를 너무 작게 설정하면 Heap Memory Full 현상 발생으로 성능 저하 가능성 존재
    * 네트워크 장비로 인한 성능 저하: 네트워크 관련 장비 간 데이터 전송 실패 또는 전송 지연에 따른 데이터 손실 발생 시 애플리케이션의 성능 저하 또는 장애 발생 가능성 존재

<hr>

* 애플리케이션 성능 테스트 수행 절차
    1. 성능 테스트 도구 설치 - 대상 시스템에 선정된 테스트 도구 설치
    2. 테스트 환경 설정 - 해당 시스템의 운영체제, DBMS 버전, 네트워크 상태 등에 대해 설정
    3. 시나리오 생성 - 테스트 목적에 맞는 부하 형태, 파라미터, 사용자 수, Ramp-up load, 수행 시간, 모니터링 결과 저장 파일 등의 정보 설정
    4. 성능 테스트 실행 및 모니터링 - 성능 테스트를 수행하면서 테스트 상황을 도구를 통해 모니터링

* 애플리케이션 성능 개선
    * 소스 코드 최적화란?   
        * 읽기 쉽고 변경 및 추가가 쉬운 클린 코드를 작성하는 것
    
* 나쁜 코드(Bad Code)란?
    * 다른 개발자가 로직(Logic)을 이해하기 어렵게 작성된 코드
    * 오염: 비즈니스 기능을 수행하지 못하는 많은 컴포넌트들이 존재
    * 문서 부족: 현재 코드와 문서가 일치하지 않고 수정과 변경을 위한 도메인 지식은 크게 증가하지만 개발자의 지식부족 초래
    * 의미 없는 이름: 함수, 클래스, 컴포넌트 이름들이 명확한 의미를 갖지 못하거나 실제 작동과 볼일치
    * 높은 결합도: 클래스와 컴포넌트 간에 데이터와 컨트롤 흐름이 네트워크로 복잡하게 연결
    * 아키텍처 침식: 아키텍처가 더 이상 구별되지 않고 여러 솔루션으로 이루어저 아키텍터상 변형들로 인해 시스템 품질이 떨어짐

* 클린 코드(Clean Code)란?
    * 잘 작성되어 가독성이 높고, 단순하며, 의존성을 줄이고, 중복을 최소화하여 깔끔하게 잘 정리된 코드
    * 중복 코드 제거로 애플리케이션의 설계가 개선됨
    * 가독성이 높으므로 애플리케이션의 기능에 대해 쉽게 이해 가능
    * 버그를 찾기 쉬워지며, 프로그래밍 속도가 빨라짐
    * 의미 있는 이름: 변수나 클래스, 메서드 명을 의도가 분명한 이름으로 사용
    * 간결하고 명확한 주석: 주석이 필요한 경우 최대한 간결하고 명확하게 작성
    * 보기 좋은 배치: 읽는 사람이 편하게 읽을 수 있도록 구성
    * 작은 함수: 함수는 가급적 작게 만들고 if문이나 while문 안의 내용은 한줄로 처리되도록 작성
    * 읽기 쉬운 제어 흐름: 조건, 루프, 흐름을 통제하는 선언문이 코드에 있으면 코드가 읽기 어려움
    * 오류 처리: 오류코드의 반환보다 예외 처리를 활용
    * 작성 원칙 -> 가독성, 단순성, 의존성 최소화, 중복성 최소화, 추상화 사용

* 소스 코드 품질분석이란?
    * 소스 코드에 대한 코딩 스타일, 설정된 코딩 표준, 코드의 복잡도, 코드 내에 존재하는 메모리 누수 현황, 스레드의 결함 등을 발견하기 위한 활동
    * 정적 분석 도구
        * 작성된 소스 코드를 실행시키지 않고, 코드 자체만으로 코딩 표준 준수 여부, 코딩 스타일 적정 여부, 잔존 결함 발견 여부를 확인하는 코드 분석 도구
        * pmd, cppcheck, SonarQube, checkstyle 등
    * 동적 분석 도구
        * 애플리케이션을 실행하여 코드에 존재하는 메모리 누수 현황을 발견하ㄱ, 발생한 스레드이 결함 등을 분석하기 위한 도구
        * Avalanche, Valgrind

* 애플리케이션 성능 개선 방안
    * 소스 코드 최적화 기법 적용
    * 아키텍처 조정을 통한 성능 개선
    * 프로그램 호출 순서 조정 적용
    * 메모리 사용 최소화 적용
    * 입출력 발생 최소화 적용
    * System.out.println()을 사용 제외